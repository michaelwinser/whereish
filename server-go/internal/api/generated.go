// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ContactRequestDirection.
const (
	Incoming ContactRequestDirection = "incoming"
	Outgoing ContactRequestDirection = "outgoing"
)

// Defines values for ContactRequestStatus.
const (
	Accepted ContactRequestStatus = "accepted"
	Declined ContactRequestStatus = "declined"
	Pending  ContactRequestStatus = "pending"
)

// Defines values for DevicePlatform.
const (
	DevicePlatformAndroid DevicePlatform = "android"
	DevicePlatformCli     DevicePlatform = "cli"
	DevicePlatformIos     DevicePlatform = "ios"
	DevicePlatformWeb     DevicePlatform = "web"
)

// Defines values for DeviceCreatePlatform.
const (
	DeviceCreatePlatformAndroid DeviceCreatePlatform = "android"
	DeviceCreatePlatformCli     DeviceCreatePlatform = "cli"
	DeviceCreatePlatformIos     DeviceCreatePlatform = "ios"
	DeviceCreatePlatformWeb     DeviceCreatePlatform = "web"
)

// Defines values for DeviceWithTokenPlatform.
const (
	Android DeviceWithTokenPlatform = "android"
	Cli     DeviceWithTokenPlatform = "cli"
	Ios     DeviceWithTokenPlatform = "ios"
	Web     DeviceWithTokenPlatform = "web"
)

// Defines values for HealthResponseStatus.
const (
	Healthy HealthResponseStatus = "healthy"
)

// Defines values for IdentityBackupAlgorithm.
const (
	AES256GCM IdentityBackupAlgorithm = "AES-256-GCM"
)

// Defines values for IdentityBackupKdf.
const (
	PBKDF2SHA256 IdentityBackupKdf = "PBKDF2-SHA256"
)

// ConflictError defines model for ConflictError.
type ConflictError struct {
	// CurrentVersion Current version on server
	CurrentVersion int `json:"currentVersion"`
	Error          struct {
		Code    string `json:"code"`
		Message string `json:"message"`
	} `json:"error"`
}

// Contact defines model for Contact.
type Contact struct {
	// CreatedAt When the contact relationship was established
	CreatedAt time.Time           `json:"createdAt"`
	Email     openapi_types.Email `json:"email"`

	// Id Contact's user ID
	Id string `json:"id"`

	// Name Contact's display name
	Name string `json:"name"`

	// PublicKey Base64-encoded X25519 public key for encrypting locations
	PublicKey string `json:"publicKey"`
}

// ContactList defines model for ContactList.
type ContactList struct {
	Contacts []Contact `json:"contacts"`
}

// ContactRequest defines model for ContactRequest.
type ContactRequest struct {
	CreatedAt time.Time `json:"createdAt"`

	// Direction Whether this is an incoming or outgoing request
	Direction *ContactRequestDirection `json:"direction,omitempty"`

	// Email Email of the other user
	Email openapi_types.Email `json:"email"`

	// Id Request ID
	Id string `json:"id"`

	// Name Name of the other user (if available)
	Name   *string              `json:"name,omitempty"`
	Status ContactRequestStatus `json:"status"`
}

// ContactRequestDirection Whether this is an incoming or outgoing request
type ContactRequestDirection string

// ContactRequestStatus defines model for ContactRequest.Status.
type ContactRequestStatus string

// ContactRequestCreate defines model for ContactRequestCreate.
type ContactRequestCreate struct {
	// Email Email of the user to send request to
	Email openapi_types.Email `json:"email"`
}

// ContactRequestList defines model for ContactRequestList.
type ContactRequestList struct {
	Incoming []ContactRequest `json:"incoming"`
	Outgoing []ContactRequest `json:"outgoing"`
}

// Device defines model for Device.
type Device struct {
	CreatedAt time.Time `json:"createdAt"`

	// Id Device ID
	Id string `json:"id"`

	// IsCurrent Whether this is the current device making the request
	IsCurrent *bool `json:"isCurrent,omitempty"`

	// IsRevoked Whether this device has been revoked
	IsRevoked *bool     `json:"isRevoked,omitempty"`
	LastSeen  time.Time `json:"lastSeen"`

	// Name User-friendly device name
	Name     string         `json:"name"`
	Platform DevicePlatform `json:"platform"`
}

// DevicePlatform defines model for Device.Platform.
type DevicePlatform string

// DeviceCreate defines model for DeviceCreate.
type DeviceCreate struct {
	// Name User-friendly device name
	Name     string               `json:"name"`
	Platform DeviceCreatePlatform `json:"platform"`
}

// DeviceCreatePlatform defines model for DeviceCreate.Platform.
type DeviceCreatePlatform string

// DeviceList defines model for DeviceList.
type DeviceList struct {
	Devices []Device `json:"devices"`
}

// DeviceWithToken defines model for DeviceWithToken.
type DeviceWithToken struct {
	CreatedAt time.Time `json:"createdAt"`

	// Id Device ID
	Id string `json:"id"`

	// IsCurrent Whether this is the current device making the request
	IsCurrent *bool `json:"isCurrent,omitempty"`

	// IsRevoked Whether this device has been revoked
	IsRevoked *bool     `json:"isRevoked,omitempty"`
	LastSeen  time.Time `json:"lastSeen"`

	// Name User-friendly device name
	Name     string                  `json:"name"`
	Platform DeviceWithTokenPlatform `json:"platform"`

	// Token Device token for API authentication
	Token string `json:"token"`
}

// DeviceWithTokenPlatform defines model for DeviceWithToken.Platform.
type DeviceWithTokenPlatform string

// EncryptedLocation defines model for EncryptedLocation.
type EncryptedLocation struct {
	// Blob Base64-encoded NaCl box ciphertext.
	// Encrypted with sender's private key + recipient's public key.
	// Contains location hierarchy, optional named location, and timestamp.
	Blob string `json:"blob"`

	// FromUserId User ID who shared this location
	FromUserId string `json:"fromUserId"`

	// UpdatedAt When the location was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// Error defines model for Error.
type Error struct {
	Error struct {
		// Code Machine-readable error code
		Code string `json:"code"`

		// Message Human-readable error message
		Message string `json:"message"`
	} `json:"error"`
}

// GoogleLoginRequest defines model for GoogleLoginRequest.
type GoogleLoginRequest struct {
	// IdToken Google OAuth ID token
	IdToken string `json:"idToken"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	Status HealthResponseStatus `json:"status"`

	// Version Server version
	Version *string `json:"version,omitempty"`
}

// HealthResponseStatus defines model for HealthResponse.Status.
type HealthResponseStatus string

// IdentityBackup defines model for IdentityBackup.
type IdentityBackup struct {
	// Algorithm Encryption algorithm
	Algorithm IdentityBackupAlgorithm `json:"algorithm"`

	// Iterations KDF iterations
	Iterations int `json:"iterations"`

	// Iv Base64-encoded IV (12 bytes)
	Iv string `json:"iv"`

	// Kdf Key derivation function
	Kdf IdentityBackupKdf `json:"kdf"`

	// Payload Base64-encoded ciphertext of encrypted keypair
	Payload string `json:"payload"`

	// Salt Base64-encoded salt (16 bytes)
	Salt string `json:"salt"`
}

// IdentityBackupAlgorithm Encryption algorithm
type IdentityBackupAlgorithm string

// IdentityBackupKdf Key derivation function
type IdentityBackupKdf string

// LocationList defines model for LocationList.
type LocationList struct {
	Locations []EncryptedLocation `json:"locations"`
}

// LocationShare defines model for LocationShare.
type LocationShare struct {
	// Blob Base64-encoded NaCl box ciphertext for this recipient
	Blob string `json:"blob"`

	// ToUserId User ID to share location with
	ToUserId string `json:"toUserId"`
}

// LocationShareRequest defines model for LocationShareRequest.
type LocationShareRequest struct {
	Locations []LocationShare `json:"locations"`
}

// LoginResponse defines model for LoginResponse.
type LoginResponse struct {
	// IsNewUser True if this is the user's first login
	IsNewUser *bool `json:"isNewUser,omitempty"`

	// Token Session token for API authentication
	Token string `json:"token"`
	User  User   `json:"user"`
}

// PublicKeyRequest defines model for PublicKeyRequest.
type PublicKeyRequest struct {
	// PublicKey Base64-encoded X25519 public key (32 bytes)
	PublicKey string `json:"publicKey"`
}

// User defines model for User.
type User struct {
	// CreatedAt Account creation timestamp
	CreatedAt time.Time `json:"createdAt"`

	// Email User's email address
	Email openapi_types.Email `json:"email"`

	// HasIdentityBackup Whether user has stored an identity backup
	HasIdentityBackup *bool `json:"hasIdentityBackup,omitempty"`

	// HasUserData Whether user has stored encrypted user data
	HasUserData *bool `json:"hasUserData,omitempty"`

	// Id Unique user identifier
	Id string `json:"id"`

	// Name Display name
	Name string `json:"name"`

	// PublicKey Base64-encoded X25519 public key
	PublicKey *string `json:"publicKey,omitempty"`
}

// UserData defines model for UserData.
type UserData struct {
	// Blob Base64-encoded encrypted blob containing named locations,
	// contact permissions, and preferences.
	// Encrypted with NaCl box to self (user's own keypair).
	Blob *string `json:"blob,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`

	// Version Version number for optimistic concurrency
	Version int `json:"version"`
}

// UserDataUpdate defines model for UserDataUpdate.
type UserDataUpdate struct {
	// Blob Base64-encoded encrypted blob
	Blob string `json:"blob"`

	// Version Expected current version (for optimistic concurrency)
	Version int `json:"version"`
}

// ContactId defines model for contactId.
type ContactId = string

// DeviceId defines model for deviceId.
type DeviceId = string

// RequestId defines model for requestId.
type RequestId = string

// BadRequest defines model for BadRequest.
type BadRequest = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// LoginWithGoogleJSONRequestBody defines body for LoginWithGoogle for application/json ContentType.
type LoginWithGoogleJSONRequestBody = GoogleLoginRequest

// SendContactRequestJSONRequestBody defines body for SendContactRequest for application/json ContentType.
type SendContactRequestJSONRequestBody = ContactRequestCreate

// RegisterDeviceJSONRequestBody defines body for RegisterDevice for application/json ContentType.
type RegisterDeviceJSONRequestBody = DeviceCreate

// SetIdentityBackupJSONRequestBody defines body for SetIdentityBackup for application/json ContentType.
type SetIdentityBackupJSONRequestBody = IdentityBackup

// SetPublicKeyJSONRequestBody defines body for SetPublicKey for application/json ContentType.
type SetPublicKeyJSONRequestBody = PublicKeyRequest

// ShareLocationsJSONRequestBody defines body for ShareLocations for application/json ContentType.
type ShareLocationsJSONRequestBody = LocationShareRequest

// SetUserDataJSONRequestBody defines body for SetUserData for application/json ContentType.
type SetUserDataJSONRequestBody = UserDataUpdate

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Delete user account
	// (DELETE /auth/account)
	DeleteAccount(w http.ResponseWriter, r *http.Request)
	// Login with Google OAuth
	// (POST /auth/google)
	LoginWithGoogle(w http.ResponseWriter, r *http.Request)
	// End current session
	// (POST /auth/logout)
	Logout(w http.ResponseWriter, r *http.Request)
	// List contacts
	// (GET /contacts)
	ListContacts(w http.ResponseWriter, r *http.Request)
	// Send contact request
	// (POST /contacts/request)
	SendContactRequest(w http.ResponseWriter, r *http.Request)
	// List contact requests
	// (GET /contacts/requests)
	ListContactRequests(w http.ResponseWriter, r *http.Request)
	// Cancel contact request
	// (DELETE /contacts/requests/{requestId})
	CancelContactRequest(w http.ResponseWriter, r *http.Request, requestId RequestId)
	// Accept contact request
	// (POST /contacts/requests/{requestId}/accept)
	AcceptContactRequest(w http.ResponseWriter, r *http.Request, requestId RequestId)
	// Decline contact request
	// (POST /contacts/requests/{requestId}/decline)
	DeclineContactRequest(w http.ResponseWriter, r *http.Request, requestId RequestId)
	// Remove contact
	// (DELETE /contacts/{contactId})
	RemoveContact(w http.ResponseWriter, r *http.Request, contactId ContactId)
	// List devices
	// (GET /devices)
	ListDevices(w http.ResponseWriter, r *http.Request)
	// Register device
	// (POST /devices)
	RegisterDevice(w http.ResponseWriter, r *http.Request)
	// Revoke device
	// (DELETE /devices/{deviceId})
	RevokeDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceId)
	// Health check
	// (GET /health)
	GetHealth(w http.ResponseWriter, r *http.Request)
	// Get encrypted identity backup
	// (GET /identity/backup)
	GetIdentityBackup(w http.ResponseWriter, r *http.Request)
	// Store encrypted identity backup
	// (PUT /identity/backup)
	SetIdentityBackup(w http.ResponseWriter, r *http.Request)
	// Register public key
	// (POST /identity/public-key)
	SetPublicKey(w http.ResponseWriter, r *http.Request)
	// Get locations from contacts
	// (GET /locations)
	GetLocations(w http.ResponseWriter, r *http.Request)
	// Share locations with contacts
	// (POST /locations)
	ShareLocations(w http.ResponseWriter, r *http.Request)
	// Get current user info
	// (GET /me)
	GetCurrentUser(w http.ResponseWriter, r *http.Request)
	// Get encrypted user data
	// (GET /user-data)
	GetUserData(w http.ResponseWriter, r *http.Request)
	// Update encrypted user data
	// (PUT /user-data)
	SetUserData(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Delete user account
// (DELETE /auth/account)
func (_ Unimplemented) DeleteAccount(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Login with Google OAuth
// (POST /auth/google)
func (_ Unimplemented) LoginWithGoogle(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// End current session
// (POST /auth/logout)
func (_ Unimplemented) Logout(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List contacts
// (GET /contacts)
func (_ Unimplemented) ListContacts(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Send contact request
// (POST /contacts/request)
func (_ Unimplemented) SendContactRequest(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List contact requests
// (GET /contacts/requests)
func (_ Unimplemented) ListContactRequests(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Cancel contact request
// (DELETE /contacts/requests/{requestId})
func (_ Unimplemented) CancelContactRequest(w http.ResponseWriter, r *http.Request, requestId RequestId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Accept contact request
// (POST /contacts/requests/{requestId}/accept)
func (_ Unimplemented) AcceptContactRequest(w http.ResponseWriter, r *http.Request, requestId RequestId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Decline contact request
// (POST /contacts/requests/{requestId}/decline)
func (_ Unimplemented) DeclineContactRequest(w http.ResponseWriter, r *http.Request, requestId RequestId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Remove contact
// (DELETE /contacts/{contactId})
func (_ Unimplemented) RemoveContact(w http.ResponseWriter, r *http.Request, contactId ContactId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List devices
// (GET /devices)
func (_ Unimplemented) ListDevices(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Register device
// (POST /devices)
func (_ Unimplemented) RegisterDevice(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Revoke device
// (DELETE /devices/{deviceId})
func (_ Unimplemented) RevokeDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Health check
// (GET /health)
func (_ Unimplemented) GetHealth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get encrypted identity backup
// (GET /identity/backup)
func (_ Unimplemented) GetIdentityBackup(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Store encrypted identity backup
// (PUT /identity/backup)
func (_ Unimplemented) SetIdentityBackup(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Register public key
// (POST /identity/public-key)
func (_ Unimplemented) SetPublicKey(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get locations from contacts
// (GET /locations)
func (_ Unimplemented) GetLocations(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Share locations with contacts
// (POST /locations)
func (_ Unimplemented) ShareLocations(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get current user info
// (GET /me)
func (_ Unimplemented) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get encrypted user data
// (GET /user-data)
func (_ Unimplemented) GetUserData(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update encrypted user data
// (PUT /user-data)
func (_ Unimplemented) SetUserData(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// DeleteAccount operation middleware
func (siw *ServerInterfaceWrapper) DeleteAccount(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAccount(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LoginWithGoogle operation middleware
func (siw *ServerInterfaceWrapper) LoginWithGoogle(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LoginWithGoogle(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Logout operation middleware
func (siw *ServerInterfaceWrapper) Logout(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Logout(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListContacts operation middleware
func (siw *ServerInterfaceWrapper) ListContacts(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListContacts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SendContactRequest operation middleware
func (siw *ServerInterfaceWrapper) SendContactRequest(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SendContactRequest(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListContactRequests operation middleware
func (siw *ServerInterfaceWrapper) ListContactRequests(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListContactRequests(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CancelContactRequest operation middleware
func (siw *ServerInterfaceWrapper) CancelContactRequest(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId RequestId

	err = runtime.BindStyledParameterWithOptions("simple", "requestId", chi.URLParam(r, "requestId"), &requestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelContactRequest(w, r, requestId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AcceptContactRequest operation middleware
func (siw *ServerInterfaceWrapper) AcceptContactRequest(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId RequestId

	err = runtime.BindStyledParameterWithOptions("simple", "requestId", chi.URLParam(r, "requestId"), &requestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AcceptContactRequest(w, r, requestId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeclineContactRequest operation middleware
func (siw *ServerInterfaceWrapper) DeclineContactRequest(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId RequestId

	err = runtime.BindStyledParameterWithOptions("simple", "requestId", chi.URLParam(r, "requestId"), &requestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeclineContactRequest(w, r, requestId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RemoveContact operation middleware
func (siw *ServerInterfaceWrapper) RemoveContact(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "contactId" -------------
	var contactId ContactId

	err = runtime.BindStyledParameterWithOptions("simple", "contactId", chi.URLParam(r, "contactId"), &contactId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "contactId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveContact(w, r, contactId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListDevices operation middleware
func (siw *ServerInterfaceWrapper) ListDevices(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDevices(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RegisterDevice operation middleware
func (siw *ServerInterfaceWrapper) RegisterDevice(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RegisterDevice(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RevokeDevice operation middleware
func (siw *ServerInterfaceWrapper) RevokeDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceId

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RevokeDevice(w, r, deviceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHealth(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetIdentityBackup operation middleware
func (siw *ServerInterfaceWrapper) GetIdentityBackup(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetIdentityBackup(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SetIdentityBackup operation middleware
func (siw *ServerInterfaceWrapper) SetIdentityBackup(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetIdentityBackup(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SetPublicKey operation middleware
func (siw *ServerInterfaceWrapper) SetPublicKey(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetPublicKey(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetLocations operation middleware
func (siw *ServerInterfaceWrapper) GetLocations(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLocations(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ShareLocations operation middleware
func (siw *ServerInterfaceWrapper) ShareLocations(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShareLocations(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCurrentUser operation middleware
func (siw *ServerInterfaceWrapper) GetCurrentUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCurrentUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserData operation middleware
func (siw *ServerInterfaceWrapper) GetUserData(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserData(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SetUserData operation middleware
func (siw *ServerInterfaceWrapper) SetUserData(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetUserData(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/account", wrapper.DeleteAccount)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/google", wrapper.LoginWithGoogle)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/logout", wrapper.Logout)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/contacts", wrapper.ListContacts)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/contacts/request", wrapper.SendContactRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/contacts/requests", wrapper.ListContactRequests)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/contacts/requests/{requestId}", wrapper.CancelContactRequest)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/contacts/requests/{requestId}/accept", wrapper.AcceptContactRequest)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/contacts/requests/{requestId}/decline", wrapper.DeclineContactRequest)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/contacts/{contactId}", wrapper.RemoveContact)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices", wrapper.ListDevices)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/devices", wrapper.RegisterDevice)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/devices/{deviceId}", wrapper.RevokeDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health", wrapper.GetHealth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/identity/backup", wrapper.GetIdentityBackup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/identity/backup", wrapper.SetIdentityBackup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/identity/public-key", wrapper.SetPublicKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/locations", wrapper.GetLocations)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/locations", wrapper.ShareLocations)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/me", wrapper.GetCurrentUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/user-data", wrapper.GetUserData)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/user-data", wrapper.SetUserData)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9RcaW/bOJj+K4R2gaZY2Tl6AJNvaZJ2stN2gqSdLtAEMzT12uJEIjUk5dQb+L8veOim",
	"JCe129l+aWzxeu+Dj/wQEJ5mnAFTMjh+CDIscAoKhPlEOFOYqItIf4hAEkEzRTkLjoNT+wjlEgS6OAvC",
	"gOqvM6ziIAwYTiE4rs0PAwH/5FRAFBwrkUMYSBJDivXCapXpwVIJyhbBeh0GESwpAd+2Z+ZJ74blxMft",
	"p8eCHKTTDenduVriMVubvWXGmQTD8Dc4urILFewHZv7EWZZQgvWh9v+W+mQPtWX/U8A8OA7+Y78S5r59",
	"KvfPheDCbtWk7IItcUKjgrJgHQYfuXrLcxbtfvMrkDwXBBDjCs3Nnusw+MxwrmIu6P/CDzjDSa5iYMqt",
	"igqpIS4QtbwxyuHW0duccjZPKFF2SW0ugmcgFLXSI7kQwNQfICS1J2zpkn2OlnYA4gxJEEsQQRjAN5xm",
	"CQTHr8JCSyhTsAChGQM9G/II9P/l5MAt/SdxJw3Cts6FQQpS4kVr4hlWGMVYohkAQymP6JxChGYrhBlX",
	"MQhkbau74Lqu8F/tmapNbsvxfPY3ENUZb0kL28zrzgsLW/TwQQBWEJ2oLs+/xMCQigGR0pATI28Z0wzd",
	"Y4lAKjxLqIxB2+6cixQr7UqwgomiKfhYCCmmid6sHG6/8Qyl/U7lmay5z85E61j6p0ZUZgleITPOMz/L",
	"Zwklv8Gqu8gbLOH1ywkwLawI/c/Rq1eHvyA7Ad3BCs25QMCIWGWKsgVKuLUROSp9qnlY8MKdrDpIWJPU",
	"gIDfU+kTsn1o/qYKUjlm+IW6rMudsBB45dFYt/DAkWpeeUD1NlOeiAogyushvsRgbE3FVCIqEWaIMsJT",
	"LQQuEM/Vguu/C58dBsDy1DDeDQvCoBhVo8ejuc2Nz/XXiM+NqVh716pZN4hHafhVPVxuqNofcQrdI6A9",
	"Okd4iWmCZwk89y0nFVa5kUbBjQxYZJmBCYFMGdOOgCSUQeThy5AWu9U31F1H+KkZ21WXTdhvqFYcSWBl",
	"dEaKbyCLtms1o8YP67e3UqMeaW9XVT7RNLuaZm5rybbcBo2gIt9mkVsxZjqSpHYnSJcGjFu/CVsuZ7DR",
	"F6X4Ttu/flL5ALfHjPMEMLObXMGS30E0solbtYz7ws3yrZlgqa4B2Oa88Zv5ZwliMhcUWJSsihO4UFHl",
	"Ix9WiF7GnPlDW4KVPkLd5CnXNopZJLgx33uYaZtN6IbmXgSrYum6vdeI71enPpP//8KFNgP6KfX7C0vD",
	"5uHZGeGYTRfL9h/nC1XxJ35nNRMnye/z4Pjrhnu3iVDFOl6LNk9NcnRyeYFwo34Y9cZ26S4Zt+swOLe5",
	"FkTvXabVZe8s4bPRTO4jPk3QjH9DhGYxCAXf1PSGlauje6piE1dAPJMoE3SJFZiM77+QAEIzCkznllUq",
	"OL1hxglTJss0EMUUBBYkXoWIm5PgxOhuVA4JEWYR0o5BKpxm0xvm0+C54Kk2BF/h/dlmxug+5kjGWBdm",
	"xmUVO/jWy7NotA4oidC5vzZr5GZtmPy3pFojIbQyqh/Dp7Q9xeNIidek5gMmMWUwEYAjnRYhMxu52qvy",
	"H66O/bMTK7zVYHOPX/MUs/YOxej6JjZ5obKsoHdUI/qY+Y7zRQLv+YKy3hSdRp/8Vm0no99PchVrVbMW",
	"Oh4tPvVYchj8CjhR8ZVr6XSP0s1UYzNj5c3Vl32NhGvTNSj6CA1hHE4PpgejNLhz+Ei4iLRPU6s3mNzl",
	"WZcEnCy4oCpOPVmsqxg5Q9WoqkQ5Ob+eHL16PXl3+sFLLlUgXJnZWfq3s7eo9rxG8eGB/hcGKWU01RsV",
	"X3S7KHQ56kAv/kB7h0dotlIgvbXGXTT3nA50CDfeVBM/zxlxLqqg/fLNb2dvjybXv54cvXrtpT7Dq4Tj",
	"aPSElWfX9QKUrv0OVhmmwlsf4USNrqsHob3D1720t1SoLmHNlIb83J6G5RVpPnUrAp4/p6gaD5tmFd1I",
	"OpZgVHsMne9ah6DtRWWTRJh4VoZdn+QUHwuPykXHWlyjpi89low0g9Yo6b3e9fEiarL0e8VjPH+fv6Xy",
	"I9xrSrsM/CRyQHTeKLZ05f1MojkVUqFEL+2thHqSxGuQpq37uCwxDHJ3viGeGRr8GaVbwMedy6Lz1iu9",
	"72kS7r042tRZVNv4jlkIaOOm7gkhPGcKmSGG5UWi+fgObtesnklkniIcRQKk3KgJFmPZjZz+ytv0d3TJ",
	"LRXXaS1miLqpaGbn+rQuxlKf7gwrvPnaVXwwTyI92dsw8LkYRv/JXTvKHnBOm3cVQS7Fn3hGDo9ebF7/",
	"nzX71tVi/81jhs74tpvZT+pZD/f66nJ4QjyohKKH25sJyihbtIooGd6w4toiA5FS41+kra0yAXMQwAjI",
	"bolXRhzTRkzmaM+5Nn7PikzheU9RNlBEva/KpSeYXG866+58EMvTGQjjOXVZmVKpKNHssU0wsmrkfd0M",
	"ryXXKj0eLsgKaX42o7Yi00eRf/4tA6Jnktb94F4/J2oud5z8ngivM0MguaBqda3DjKMWsAChSyIPzeaZ",
	"C3DNwDZFb40SHKO/3KgHaeOhqZbWf92wG/aWF9eIE5kBoXNKkOa003ZEGUnyCIp2mNmnb8HjBzuqXD5w",
	"V7XGs5kZFY9ipTJ7BUzZnNduk6oGnXahAqiMg85F8aXO7MlqYvMCCSnWZFcZl07AtPWeXF5MNZknSYIk",
	"MEkVXYLxuWivsmln5FmCCciwbtjPdR5SKRJJdFo4kTSC6Q37FIO7Lba+XbZUTiKqEMGMcYV00R4iTMzl",
	"HZYIIyNoMJefK2v3CSXgcibHgA8Xn0x2Q1VS54cmK6iprysx12HAM2A4o8Fx8GJ6MH1hMn0VGy3a19qx",
	"j22ctoqUgPJEg0sQKda5jumC6jFVKobcfOPvcJIgLCUnVJuy4arhCpWGUM4K4meAchZxBpbOUr90Fh2c",
	"mS1c/hC00BdHBy/7cw17OANTeHlw2JevlevtN7AMxtbyNMViVR6iQaJWVbyQprDSpnerZ1gmLkyXwrgl",
	"LpXPfZAYswUgjLwNDeNPMSrF6axoesNsx1o2eU3n9fzXx0OTc3+hKrbbBSV+5g2PVluDbXg6O+umi1Mi",
	"h3VHhAdbO0GztvAASMwAJHNCQMp5nljdOBjXjRrM5+nq5Fx3cPz1tq5c9lAmC6irw4CCJXzBc9WvYA4o",
	"hAvTLMKUrNc7U5+a6GU3sTE7tMPJ77Oycxa1j+pnQh1YsADlu8xWuWDSuiB3n1zgSaRltYqBilrSqXOy",
	"y+oT0hU6A9CZguKF564SPf1lsaDX5KhUp8Uxd6jydQCGT+GpNF2nkmNbEJNZk1S0FQKqUBkNIe2LWinr",
	"VddrYJEOeaSF3FO8hDIZhzdb2TJvesMu5u5G1bViUMRBsmcKxXgJuj5zzjFEjJfrUYlcleCTmD5F6/Z6",
	"N37SizvYyFMe7ugMfryfZZrUe/0wN6knvdw9kND04hpAxpcHv/wIDKXlKU50vrdC8I1KJZGO9u6byk4b",
	"Jqd1s20em1veuJ+ccRVXuCWdvJXAJQfMae8up0Mu76rYePeer46I8bC8hQbeugOsFt5cHPsPJfZ4PZRp",
	"n2JGIDGYslIcrW27UrCTOo6sDhPvuWqvhuxX2Oj17SbpQKHYxGyePDnpLs1/eFKJem7KxZL+HXZSF8y+",
	"zRv6o9aJed5E/LWlc8PeaMvS0UuiGRCeQpWGaDMjmLVuA7zZhN1rl0Ldul0O+j+XkoVIOAfE4L5gzE9R",
	"HcvgbamOwy32686ZHTCsPJ5S2Mz6SbZdgjF/hnwc6U8Q0EP5Ssugr72ClC+hmYVWsPMpqtlxwiUYFZam",
	"CgBMYot+fVZhXVz7p5a8UmkSDsZNU96bgdozFPbzWLlWr+5sJtcqMupdf45YLcWl5fdKs4ZUG6333Fgk",
	"YEGlAmELuNploSsN/AnMmdtphw6yBskbqNgKkreVr0QlYQWPS5zeOuxxU1eOhdostId2XV57E97h5w0r",
	"xdDoB5vxMp9JbbNMmTtWgpNE+m3AbnlWvLuyiwqsAf/8wZVXGwHpUQGHXawU+Me2qWrWaQ9Qe5Goozo1",
	"69x/KF7mG/G0S34HlZKEKBOwBGZa31ShueCpc68FcNq26bVDjQrWWHwjZivjcpNkhQgmcdVm9iiW3rZU",
	"q8f51vItxc1caylAi83+OZ5V7z0mOYtlG3Wr7hbDjkYWijZFH3nrRqmEE3Zd6ztQFmm3S8fawvJ5LMvB",
	"8KhEBYpvqDFr10MkBnLnb0QWKID9WYkg6GOkoLCEBmilug1qgQmcrtsPzRsm07rE6PLi48TA1yyMzJYS",
	"Bei3toW7OPbZwztQLfjDDiXT2skjmfM+Zvy7G0kfefu8rqnTMsd3oPrlXdOt4okNyrmvWWqvEh+vRzLm",
	"eRKhGfgvLHtUy98p9anO9sO0T2vGArXHG1+0BGSBNj8pphrxPVYVGq7GXllM7iyyZixxq+lJ523RaKL4",
	"BFgJhbB1y+9lzSI71x72atyk01QOqMdl7QXSXWhGByb3VN2obnz+RelWEwnlV4cGiHMk5lTaVsrR4g/c",
	"WxqzVf0q61zXswbm1I08JUpp71GvpDzvCUDva28p7/BSuIZXHow81eWeyUG3eWem/X/f8pWMa8jZ3prM",
	"aKyMh8TavJqs5OmLAE2xFpVdifUp5ek1dK0+TRlu39S9mOanmnt5WKf6PysINDu+Vggj+qCN3oIzB1N1",
	"yiy0z7zSMeO5MvKs5ekOWOpN0d17rp/te+Q7s0gHje7e1bi7f9svY3O+LcsjnYW92bx+PIkcSvQpebyJ",
	"jltDiPokVOJYdywes8egs6zQyf/2BL086SapeQN07VSk0overNwiUcfUYnrDPkuQPQhRNKm/JY7SXKoS",
	"X6kfQIE6dcC+ntyroSLb98ct7O0PRngN6ebnUs7F+6E/FLbwyzZv0Go/WuShtIBfl78Z1NRoK5pHKHWr",
	"CdKEFH+9Xd/qx2JZNMta96CXF2iGJSD381q5SILjYB9n1HTL3H4Pwz/lpL1fgU5LMcMLSO0LVg7parz0",
	"OnzYtGtg3WmV3PvWLDPqoXUr52H8+p4HBBzW/fbzav2Kw90NTj2XTPZGuIYnaP4mmxw8ZwfaPAN1D8Dq",
	"aYVbr8oqugs2Ws+iko2AZfUWd+On22Swvl3/XwAAAP//RLPuqZVOAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
